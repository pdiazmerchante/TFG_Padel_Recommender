---
title: "EDA - Sistema de recomendación de estrategias deportivas en pádel"
author: "Pablo Díaz Merchante"
format: 
  html:
    toc: true
    toc-location: left
    self-contained: true
    embed-resources: true
execute:
  python: "C:/Users/user/Desktop/TFG_Padel_Recommender/.venv/Scripts/python.exe"
  echo: true
  warning: true
  message: true
---




# Introducción y definición de objetivos

Este documento realiza un Análisis Exploratorio de Datos (EDA) del dataset resumen_juegos.xlsx, centrado en evaluar el rendimiento de los jugadores de pádel y preparar el terreno para la creación del sistema de recomendación de estrategias.
Se estudian:

- Estructura del dataset

- Distribución de todas las variables

- Comparaciones por jugador

- Relaciones estadísticas entre métricas

- Posibles patrones útiles para el recomendador

# Importación de datos y carga de paquetes

```{python}
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

sns.set(style="whitegrid")

# Cargar todas las hojas del Excel

#sheets = pd.read_excel("resumen_juegos.xlsx", sheet_name=None)

#df_list = []

#for name, sheet in sheets.items():
  #sheet["partido"] = name  # Añadimos nombre del partido
  #df_list.append(sheet)

# Unimos todo en un único DataFrame

#df = pd.concat(df_list, ignore_index=True)

#df.head()


df = pd.read_excel("resumen_partido.xlsx")
df.head()


```


# Diccionario de datos

- jugador: nombre del jugador

- bola dentro: golpes correctos

- error no forzado: fallos sin presión

- missed: fallos

- winner: golpes ganadores

- total: golpes totales

Variables %: cada métrica expresada sobre el total

Se incluye una fila final denominada SUMA, que no pertenece al análisis jugador a jugador

# Limpieza inicial
```{python}
# Eliminamos filas tipo SUMA

df = df[df["jugador"].str.upper() != "SUMA"]

# Convirtiendo columnas numéricas correctamente

numeric_cols_original = ["bola dentro", "error no forzado", "missed", "winner", "total"]

for col in numeric_cols_original:
  df[col] = pd.to_numeric(df[col], errors="coerce")

df.info()


```

# Tratamiento de valores nulos

En los datos, el hecho de que un valor sea 0 no es faltante, es algo que tiene sentido. Puede haber 0 errores no forzados y que no sea malo.

```{python}
# Rellenar valores vacíos con 0
num_cols = ["bola dentro","error no forzado","missed","winner","total","fuerza error"]

for col in num_cols:
    if col in df.columns:
        df[col] = df[col].fillna(0)

# Recalcular porcentajes correctamente
df["bola dentro_%"] = df["bola dentro"] / df["total"]
df["error no forzado_%"] = df["error no forzado"] / df["total"]
df["missed_%"] = df["missed"] / df["total"]
df["winner_%"] = df["winner"] / df["total"]
df["fuerza error_%"] = df["fuerza error"] / df["total"]



```
 

Crear la lista final de columnas
```{python}
pct_cols = ["bola dentro_%", "error no forzado_%", "missed_%", "winner_%"]
numeric_cols = numeric_cols_original + pct_cols

```



# Resumen estadístico
```{python}
df.describe(include="all")

```

# Análisis de valores faltantes y duplicados
```{python}
print("Valores faltantes:")
display(df.isna().sum())

print("Duplicados:")
df.duplicated().sum()


```

No tenemos valores faltantes en nuestro dataset

# Distribución de variables numéricas (variable a variable)
```{python}
numeric_cols = ['bola dentro', 'error no forzado', 'missed', 'winner']

for col in numeric_cols:
    fig, axes = plt.subplots(2, 1, figsize=(7, 6))  # tamaño perfecto

    # Histograma
    sns.histplot(df[col], kde=True, ax=axes[0])
    axes[0].set_title(f"Histograma de {col}", fontsize=11)
    axes[0].set_xlabel("")  # quita texto extra

    # Boxplot
    sns.boxplot(x=df[col], ax=axes[1])
    axes[1].set_title(f"Boxplot de {col}", fontsize=11)

    plt.tight_layout()
    plt.show()

```


# Distribución de porcentajes
```{python}
pct_cols = [c for c in df.columns if c.endswith("%")]

fig, axes = plt.subplots(len(pct_cols), 2, figsize=(12, 30))

for i, col in enumerate(pct_cols):
  sns.histplot(df[col], kde=True, ax=axes[i,0])
  axes[i,0].set_title(f"Histograma de {col}")

  sns.boxplot(x=df[col], ax=axes[i,1])
  axes[i,1].set_title(f"Boxplot de {col}")

plt.tight_layout()
plt.show()


```


# Análisis por jugador

## Estadísticas por jugador
```{python}
df.groupby("jugador")[numeric_cols + pct_cols].mean().round(2)
```

## Barplots comparativos por jugador
```{python}
plt.figure(figsize=(12,6))
sns.barplot(data=df, x="jugador", y="bola dentro")
plt.title("Bolas dentro por jugador")
plt.xticks(rotation=45)
plt.show()

```


```{python}
plt.figure(figsize=(12,6))
sns.barplot(data=df, x="jugador", y="missed")
plt.title("Missed por jugador")
plt.xticks(rotation=45)
plt.show()

```

```{python}
plt.figure(figsize=(12,6))
sns.barplot(data=df, x="jugador", y="error no forzado")
plt.title("Errores no forzados por jugador")
plt.xticks(rotation=45)
plt.show()

```

```{python}
plt.figure(figsize=(12,6))
sns.barplot(data=df, x="jugador", y="winner")
plt.title("Winners por jugador")
plt.xticks(rotation=45)
plt.show()

```





# Análisis comparativo entre jugadores

## Ranking por métrica

```{python}
for col in pct_cols:
  print(f"\nRanking por {col}")
  display(df[["jugador", col]].sort_values(col, ascending=False).reset_index(drop=True))


```

# Correlación entre variables

## Heatmap de correlaciones

```{python}
plt.figure(figsize=(12,6))
sns.heatmap(df[numeric_cols + pct_cols].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Matriz de correlación")
plt.show()

```

## Pairplot de variables clave

```{python}
sns.pairplot(df[pct_cols])
plt.show()

```

# Análisis de clúster (descubrimiento de perfiles de jugadores)

```{python}
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns

# 1. FILTRADO: Excluimos las filas donde 'jugador' sea MEDIA o STD
# El símbolo '~' significa "NO", y '.isin' comprueba si está en la lista.
df_clean = df[~df["jugador"].isin(["MEDIA", "STD"])].copy()

# 2. Preparamos los datos usando el dataframe filtrado (df_clean)
X = df_clean[pct_cols].fillna(0)

# 3. Escalado
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 4. Clusterización
kmeans = KMeans(n_clusters=3, random_state=42)
# Importante: Asignamos el cluster al dataframe filtrado, no al original completo
df_clean["cluster"] = kmeans.fit_predict(X_scaled)

# 5. Visualización
sns.scatterplot(data=df_clean, x="winner_%", y="error no forzado_%", hue="cluster")
plt.title("Clusterización de jugadores según rendimiento (Sin MEDIA/STD)")
plt.show()

# Mostrar resultados
print(df_clean[["jugador", "cluster"]])

```

# Conclusiones del EDA

- La distribución de errores, winners y bolas dentro muestra patrones claros entre jugadores, base para un modelo de recomendación.

- Se detectan perfiles diferenciados: jugadores más ofensivos (más winners) y otros más consistentes (menos errores).

- La correlación muestra relaciones útiles:

- Más winners → más riesgo → más errores

- Mayor bola dentro_% indica consistencia

- La clusterización permite agrupar jugadores en perfiles tácticos, lo que facilita recomendar emparejamientos o estrategias.

- Este EDA proporciona las bases necesarias para construir un recomendador de estrategias y parejas óptimas en pádel.